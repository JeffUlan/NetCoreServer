// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// Version: 1.8.0.0

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace simple {

    public struct SimpleRequest : IComparable, IComparable<SimpleRequest>, IEquatable<SimpleRequest>
    {
        public Guid id;
        public string Message;

        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        public static SimpleRequest Default => new SimpleRequest
        {
            id = FBE.UuidGenerator.Sequential()
            , Message = ""
        };

        public SimpleRequest(Guid id, string Message)
        {
            this.id = id;
            this.Message = Message;
        }

        public SimpleRequest Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.simple.SimpleRequestModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.simple.SimpleRequestModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((SimpleRequest)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(SimpleRequest other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleRequest))
                return false;
            if (!id.Equals(((SimpleRequest)other).id))
                return false;
            return true;
        }

        public bool Equals(SimpleRequest other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleRequest(");
            sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
            sb.Append(",Message="); if (Message != null) sb.Append("\"").Append(Message).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static FBE.FieldModelValueType<SimpleRequest> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.simple.FieldModelSimpleRequest(buffer, offset); }
    }

} // namespace simple

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleRequest field model
    public class FieldModelSimpleRequest : FieldModelValueType<SimpleRequest>
    {
        public readonly FieldModelValueType<Guid> id;
        public readonly FieldModelReferenceType<string> Message;

        public FieldModelSimpleRequest(Buffer buffer, long offset) : base(buffer, offset)
        {
            id = FieldModelValueType<Guid>.CreateFieldModel(BaseTypes.UUID, buffer, 4 + 4);
            Message = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + Message.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + Message.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<SimpleRequest> Clone() { return new FieldModelSimpleRequest(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Message.FBESize) > fbeStructSize)
                return true;
            if (!Message.Verify())
                return false;
            fbeCurrentSize += Message.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleRequest fbeValue) { Get(out fbeValue, SimpleRequest.Default); }
        public override void Get(out SimpleRequest fbeValue, SimpleRequest defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleRequest fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleRequest.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id, FBE.UuidGenerator.Sequential());
            else
                fbeValue.id = FBE.UuidGenerator.Sequential();
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Message.FBESize) <= fbeStructSize)
                Message.Get(out fbeValue.Message);
            else
                fbeValue.Message = "";
            fbeCurrentSize += Message.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleRequest fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleRequest fbeValue)
        {
            id.Set(fbeValue.id);
            Message.Set(fbeValue.Message);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleRequest model
    public class SimpleRequestModel : Model
    {
        public readonly FieldModelSimpleRequest model;

        public SimpleRequestModel() { model = new FieldModelSimpleRequest(Buffer, 4); }
        public SimpleRequestModel(Buffer buffer) : base(buffer) { model = new FieldModelSimpleRequest(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleRequest.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleRequest value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleRequest value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleRequest.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleRequest.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace simple
} // namespace FBE

namespace simple {

    public struct SimpleResponse : IComparable, IComparable<SimpleResponse>, IEquatable<SimpleResponse>
    {
        public Guid id;
        public uint Length;
        public uint Hash;

        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        public static SimpleResponse Default => new SimpleResponse
        {
            id = FBE.UuidGenerator.Sequential()
            , Length = (uint)0U
            , Hash = (uint)0U
        };

        public SimpleResponse(Guid id, uint Length, uint Hash)
        {
            this.id = id;
            this.Length = Length;
            this.Hash = Hash;
        }

        public SimpleResponse Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.simple.SimpleResponseModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.simple.SimpleResponseModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((SimpleResponse)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(SimpleResponse other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleResponse))
                return false;
            if (!id.Equals(((SimpleResponse)other).id))
                return false;
            return true;
        }

        public bool Equals(SimpleResponse other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleResponse(");
            sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
            sb.Append(",Length="); sb.Append(Length);
            sb.Append(",Hash="); sb.Append(Hash);
            sb.Append(")");
            return sb.ToString();
        }

        public static FBE.FieldModelValueType<SimpleResponse> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.simple.FieldModelSimpleResponse(buffer, offset); }
    }

} // namespace simple

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleResponse field model
    public class FieldModelSimpleResponse : FieldModelValueType<SimpleResponse>
    {
        public readonly FieldModelValueType<Guid> id;
        public readonly FieldModelValueType<uint> Length;
        public readonly FieldModelValueType<uint> Hash;

        public FieldModelSimpleResponse(Buffer buffer, long offset) : base(buffer, offset)
        {
            id = FieldModelValueType<Guid>.CreateFieldModel(BaseTypes.UUID, buffer, 4 + 4);
            Length = FieldModelValueType<uint>.CreateFieldModel(BaseTypes.UINT32, buffer, id.FBEOffset + id.FBESize);
            Hash = FieldModelValueType<uint>.CreateFieldModel(BaseTypes.UINT32, buffer, Length.FBEOffset + Length.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + Length.FBESize
                    + Hash.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + Length.FBEExtra
                    + Hash.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<SimpleResponse> Clone() { return new FieldModelSimpleResponse(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Length.FBESize) > fbeStructSize)
                return true;
            if (!Length.Verify())
                return false;
            fbeCurrentSize += Length.FBESize;

            if ((fbeCurrentSize + Hash.FBESize) > fbeStructSize)
                return true;
            if (!Hash.Verify())
                return false;
            fbeCurrentSize += Hash.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleResponse fbeValue) { Get(out fbeValue, SimpleResponse.Default); }
        public override void Get(out SimpleResponse fbeValue, SimpleResponse defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleResponse fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleResponse.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id, FBE.UuidGenerator.Sequential());
            else
                fbeValue.id = FBE.UuidGenerator.Sequential();
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Length.FBESize) <= fbeStructSize)
                Length.Get(out fbeValue.Length);
            else
                fbeValue.Length = (uint)0U;
            fbeCurrentSize += Length.FBESize;

            if ((fbeCurrentSize + Hash.FBESize) <= fbeStructSize)
                Hash.Get(out fbeValue.Hash);
            else
                fbeValue.Hash = (uint)0U;
            fbeCurrentSize += Hash.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleResponse fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleResponse fbeValue)
        {
            id.Set(fbeValue.id);
            Length.Set(fbeValue.Length);
            Hash.Set(fbeValue.Hash);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleResponse model
    public class SimpleResponseModel : Model
    {
        public readonly FieldModelSimpleResponse model;

        public SimpleResponseModel() { model = new FieldModelSimpleResponse(Buffer, 4); }
        public SimpleResponseModel(Buffer buffer) : base(buffer) { model = new FieldModelSimpleResponse(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleResponse.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleResponse value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleResponse value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleResponse.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleResponse.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace simple
} // namespace FBE

namespace simple {

    public struct SimpleReject : IComparable, IComparable<SimpleReject>, IEquatable<SimpleReject>
    {
        public Guid id;
        public string Error;

        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        public static SimpleReject Default => new SimpleReject
        {
            id = FBE.UuidGenerator.Sequential()
            , Error = ""
        };

        public SimpleReject(Guid id, string Error)
        {
            this.id = id;
            this.Error = Error;
        }

        public SimpleReject Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.simple.SimpleRejectModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.simple.SimpleRejectModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((SimpleReject)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(SimpleReject other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleReject))
                return false;
            if (!id.Equals(((SimpleReject)other).id))
                return false;
            return true;
        }

        public bool Equals(SimpleReject other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleReject(");
            sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
            sb.Append(",Error="); if (Error != null) sb.Append("\"").Append(Error).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static FBE.FieldModelValueType<SimpleReject> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.simple.FieldModelSimpleReject(buffer, offset); }
    }

} // namespace simple

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleReject field model
    public class FieldModelSimpleReject : FieldModelValueType<SimpleReject>
    {
        public readonly FieldModelValueType<Guid> id;
        public readonly FieldModelReferenceType<string> Error;

        public FieldModelSimpleReject(Buffer buffer, long offset) : base(buffer, offset)
        {
            id = FieldModelValueType<Guid>.CreateFieldModel(BaseTypes.UUID, buffer, 4 + 4);
            Error = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + Error.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + Error.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<SimpleReject> Clone() { return new FieldModelSimpleReject(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Error.FBESize) > fbeStructSize)
                return true;
            if (!Error.Verify())
                return false;
            fbeCurrentSize += Error.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleReject fbeValue) { Get(out fbeValue, SimpleReject.Default); }
        public override void Get(out SimpleReject fbeValue, SimpleReject defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleReject fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleReject.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id, FBE.UuidGenerator.Sequential());
            else
                fbeValue.id = FBE.UuidGenerator.Sequential();
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + Error.FBESize) <= fbeStructSize)
                Error.Get(out fbeValue.Error);
            else
                fbeValue.Error = "";
            fbeCurrentSize += Error.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleReject fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleReject fbeValue)
        {
            id.Set(fbeValue.id);
            Error.Set(fbeValue.Error);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleReject model
    public class SimpleRejectModel : Model
    {
        public readonly FieldModelSimpleReject model;

        public SimpleRejectModel() { model = new FieldModelSimpleReject(Buffer, 4); }
        public SimpleRejectModel(Buffer buffer) : base(buffer) { model = new FieldModelSimpleReject(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleReject.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleReject value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleReject value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleReject.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleReject.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace simple
} // namespace FBE

namespace simple {

    public struct SimpleNotify : IComparable, IComparable<SimpleNotify>, IEquatable<SimpleNotify>
    {
        public string Notification;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 4;
        public long FBEType => FBETypeConst;

        public static SimpleNotify Default => new SimpleNotify
        {
            Notification = ""
        };

        public SimpleNotify(string Notification)
        {
            this.Notification = Notification;
        }

        public SimpleNotify Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.simple.SimpleNotifyModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.simple.SimpleNotifyModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(SimpleNotify other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleNotify))
                return false;
            return true;
        }

        public bool Equals(SimpleNotify other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleNotify(");
            sb.Append("Notification="); if (Notification != null) sb.Append("\"").Append(Notification).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static FBE.FieldModelValueType<SimpleNotify> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.simple.FieldModelSimpleNotify(buffer, offset); }
    }

} // namespace simple

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleNotify field model
    public class FieldModelSimpleNotify : FieldModelValueType<SimpleNotify>
    {
        public readonly FieldModelReferenceType<string> Notification;

        public FieldModelSimpleNotify(Buffer buffer, long offset) : base(buffer, offset)
        {
            Notification = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + Notification.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + Notification.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 4;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<SimpleNotify> Clone() { return new FieldModelSimpleNotify(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + Notification.FBESize) > fbeStructSize)
                return true;
            if (!Notification.Verify())
                return false;
            fbeCurrentSize += Notification.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleNotify fbeValue) { Get(out fbeValue, SimpleNotify.Default); }
        public override void Get(out SimpleNotify fbeValue, SimpleNotify defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleNotify fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleNotify.Default;

            if ((fbeCurrentSize + Notification.FBESize) <= fbeStructSize)
                Notification.Get(out fbeValue.Notification);
            else
                fbeValue.Notification = "";
            fbeCurrentSize += Notification.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleNotify fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleNotify fbeValue)
        {
            Notification.Set(fbeValue.Notification);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding SimpleNotify model
    public class SimpleNotifyModel : Model
    {
        public readonly FieldModelSimpleNotify model;

        public SimpleNotifyModel() { model = new FieldModelSimpleNotify(Buffer, 4); }
        public SimpleNotifyModel(Buffer buffer) : base(buffer) { model = new FieldModelSimpleNotify(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleNotify.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleNotify value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleNotify value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleNotify.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleNotify.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace simple
} // namespace FBE

namespace simple {

    public struct DisconnectRequest : IComparable, IComparable<DisconnectRequest>, IEquatable<DisconnectRequest>
    {
        public Guid id;

        public const long FBETypeConst = 5;
        public long FBEType => FBETypeConst;

        public static DisconnectRequest Default => new DisconnectRequest
        {
            id = FBE.UuidGenerator.Sequential()
        };

        public DisconnectRequest(Guid id)
        {
            this.id = id;
        }

        public DisconnectRequest Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.simple.DisconnectRequestModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.simple.DisconnectRequestModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((DisconnectRequest)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(DisconnectRequest other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is DisconnectRequest))
                return false;
            if (!id.Equals(((DisconnectRequest)other).id))
                return false;
            return true;
        }

        public bool Equals(DisconnectRequest other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("DisconnectRequest(");
            sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
            sb.Append(")");
            return sb.ToString();
        }

        public static FBE.FieldModelValueType<DisconnectRequest> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.simple.FieldModelDisconnectRequest(buffer, offset); }
    }

} // namespace simple

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding DisconnectRequest field model
    public class FieldModelDisconnectRequest : FieldModelValueType<DisconnectRequest>
    {
        public readonly FieldModelValueType<Guid> id;

        public FieldModelDisconnectRequest(Buffer buffer, long offset) : base(buffer, offset)
        {
            id = FieldModelValueType<Guid>.CreateFieldModel(BaseTypes.UUID, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 5;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<DisconnectRequest> Clone() { return new FieldModelDisconnectRequest(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out DisconnectRequest fbeValue) { Get(out fbeValue, DisconnectRequest.Default); }
        public override void Get(out DisconnectRequest fbeValue, DisconnectRequest defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out DisconnectRequest fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = DisconnectRequest.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id, FBE.UuidGenerator.Sequential());
            else
                fbeValue.id = FBE.UuidGenerator.Sequential();
            fbeCurrentSize += id.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(DisconnectRequest fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(DisconnectRequest fbeValue)
        {
            id.Set(fbeValue.id);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    using global::simple;

    // Fast Binary Encoding DisconnectRequest model
    public class DisconnectRequestModel : Model
    {
        public readonly FieldModelDisconnectRequest model;

        public DisconnectRequestModel() { model = new FieldModelDisconnectRequest(Buffer, 4); }
        public DisconnectRequestModel(Buffer buffer) : base(buffer) { model = new FieldModelDisconnectRequest(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelDisconnectRequest.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(DisconnectRequest value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out DisconnectRequest value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = DisconnectRequest.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = DisconnectRequest.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    // Fast Binary Encoding simple protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 1;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    // Fast Binary Encoding simple sender listener interface
    public interface ISenderListener : FBE.ISenderListener
    {
    }

    // Fast Binary Encoding simple sender
    public class Sender : FBE.Sender, ISenderListener
    {
        // Sender models accessors
        public readonly SimpleRequestModel SimpleRequestModel;
        public readonly SimpleResponseModel SimpleResponseModel;
        public readonly SimpleRejectModel SimpleRejectModel;
        public readonly SimpleNotifyModel SimpleNotifyModel;
        public readonly DisconnectRequestModel DisconnectRequestModel;

        public Sender() : base(false)
        {
            SimpleRequestModel = new SimpleRequestModel(Buffer);
            SimpleResponseModel = new SimpleResponseModel(Buffer);
            SimpleRejectModel = new SimpleRejectModel(Buffer);
            SimpleNotifyModel = new SimpleNotifyModel(Buffer);
            DisconnectRequestModel = new DisconnectRequestModel(Buffer);
        }
        public Sender(Buffer buffer) : base(buffer, false)
        {
            SimpleRequestModel = new SimpleRequestModel(Buffer);
            SimpleResponseModel = new SimpleResponseModel(Buffer);
            SimpleRejectModel = new SimpleRejectModel(Buffer);
            SimpleNotifyModel = new SimpleNotifyModel(Buffer);
            DisconnectRequestModel = new DisconnectRequestModel(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                case global::simple.SimpleRequest value when value.FBEType == global::simple.SimpleRequest.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleResponse value when value.FBEType == global::simple.SimpleResponse.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleReject value when value.FBEType == global::simple.SimpleReject.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleNotify value when value.FBEType == global::simple.SimpleNotify.FBETypeConst: return SendListener(listener, value);
                case global::simple.DisconnectRequest value when value.FBEType == global::simple.DisconnectRequest.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::simple.SimpleRequest value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::simple.SimpleRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRequestModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleRequest serialization failed!");
            Debug.Assert(SimpleRequestModel.Verify(), "simple.SimpleRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleResponse value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::simple.SimpleResponse value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleResponseModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleResponse serialization failed!");
            Debug.Assert(SimpleResponseModel.Verify(), "simple.SimpleResponse validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleReject value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::simple.SimpleReject value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRejectModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleReject serialization failed!");
            Debug.Assert(SimpleRejectModel.Verify(), "simple.SimpleReject validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleNotify value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::simple.SimpleNotify value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleNotifyModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleNotify serialization failed!");
            Debug.Assert(SimpleNotifyModel.Verify(), "simple.SimpleNotify validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.DisconnectRequest value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::simple.DisconnectRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = DisconnectRequestModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.DisconnectRequest serialization failed!");
            Debug.Assert(DisconnectRequestModel.Verify(), "simple.DisconnectRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    // Fast Binary Encoding simple receiver listener interface
    public interface IReceiverListener : FBE.IReceiverListener
    {
        // Receive handlers
        void OnReceive(global::simple.SimpleRequest value) {}
        void OnReceive(global::simple.SimpleResponse value) {}
        void OnReceive(global::simple.SimpleReject value) {}
        void OnReceive(global::simple.SimpleNotify value) {}
        void OnReceive(global::simple.DisconnectRequest value) {}
    }

    // Fast Binary Encoding simple receiver
    public class Receiver : FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors
        private global::simple.SimpleRequest SimpleRequestValue;
        private global::simple.SimpleResponse SimpleResponseValue;
        private global::simple.SimpleReject SimpleRejectValue;
        private global::simple.SimpleNotify SimpleNotifyValue;
        private global::simple.DisconnectRequest DisconnectRequestValue;

        // Receiver models accessors
        private readonly SimpleRequestModel SimpleRequestModel;
        private readonly SimpleResponseModel SimpleResponseModel;
        private readonly SimpleRejectModel SimpleRejectModel;
        private readonly SimpleNotifyModel SimpleNotifyModel;
        private readonly DisconnectRequestModel DisconnectRequestModel;

        public Receiver() : base(false)
        {
            SimpleRequestValue = global::simple.SimpleRequest.Default;
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseValue = global::simple.SimpleResponse.Default;
            SimpleResponseModel = new SimpleResponseModel();
            SimpleRejectValue = global::simple.SimpleReject.Default;
            SimpleRejectModel = new SimpleRejectModel();
            SimpleNotifyValue = global::simple.SimpleNotify.Default;
            SimpleNotifyModel = new SimpleNotifyModel();
            DisconnectRequestValue = global::simple.DisconnectRequest.Default;
            DisconnectRequestModel = new DisconnectRequestModel();
        }
        public Receiver(Buffer buffer) : base(buffer, false)
        {
            SimpleRequestValue = global::simple.SimpleRequest.Default;
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseValue = global::simple.SimpleResponse.Default;
            SimpleResponseModel = new SimpleResponseModel();
            SimpleRejectValue = global::simple.SimpleReject.Default;
            SimpleRejectModel = new SimpleRejectModel();
            SimpleNotifyValue = global::simple.SimpleNotify.Default;
            SimpleNotifyModel = new SimpleNotifyModel();
            DisconnectRequestValue = global::simple.DisconnectRequest.Default;
            DisconnectRequestModel = new DisconnectRequestModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRequestModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestModel.Verify(), "simple.SimpleRequest validation failed!");
                    long deserialized = SimpleRequestModel.Deserialize(out SimpleRequestValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRequestValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRequestValue);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleResponseModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseModel.Verify(), "simple.SimpleResponse validation failed!");
                    long deserialized = SimpleResponseModel.Deserialize(out SimpleResponseValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleResponse deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleResponseValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleResponseValue);
                    return true;
                }
                case SimpleRejectModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRejectModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRejectModel.Verify(), "simple.SimpleReject validation failed!");
                    long deserialized = SimpleRejectModel.Deserialize(out SimpleRejectValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleReject deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRejectValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRejectValue);
                    return true;
                }
                case SimpleNotifyModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleNotifyModel.Attach(buffer, offset);
                    Debug.Assert(SimpleNotifyModel.Verify(), "simple.SimpleNotify validation failed!");
                    long deserialized = SimpleNotifyModel.Deserialize(out SimpleNotifyValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleNotify deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleNotifyValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleNotifyValue);
                    return true;
                }
                case DisconnectRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    DisconnectRequestModel.Attach(buffer, offset);
                    Debug.Assert(DisconnectRequestModel.Verify(), "simple.DisconnectRequest validation failed!");
                    long deserialized = DisconnectRequestModel.Deserialize(out DisconnectRequestValue);
                    Debug.Assert((deserialized > 0), "simple.DisconnectRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = DisconnectRequestValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(DisconnectRequestValue);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    // Fast Binary Encoding simple proxy listener interface
    public interface IProxyListener : FBE.IReceiverListener
    {
        // Proxy handlers
        void OnProxy(SimpleRequestModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(SimpleResponseModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(SimpleRejectModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(SimpleNotifyModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(DisconnectRequestModel model, long type, byte[] buffer, long offset, long size) {}
    }

    // Fast Binary Encoding simple proxy
    public class Proxy : FBE.Receiver, IProxyListener
    {
        // Proxy models accessors
        private readonly SimpleRequestModel SimpleRequestModel;
        private readonly SimpleResponseModel SimpleResponseModel;
        private readonly SimpleRejectModel SimpleRejectModel;
        private readonly SimpleNotifyModel SimpleNotifyModel;
        private readonly DisconnectRequestModel DisconnectRequestModel;

        public Proxy() : base(false)
        {
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseModel = new SimpleResponseModel();
            SimpleRejectModel = new SimpleRejectModel();
            SimpleNotifyModel = new SimpleNotifyModel();
            DisconnectRequestModel = new DisconnectRequestModel();
        }
        public Proxy(Buffer buffer) : base(buffer, false)
        {
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseModel = new SimpleResponseModel();
            SimpleRejectModel = new SimpleRejectModel();
            SimpleNotifyModel = new SimpleNotifyModel();
            DisconnectRequestModel = new DisconnectRequestModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleRequestModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleRequestModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestModel.Verify(), "simple.SimpleRequest validation failed!");

                    long fbeBegin = SimpleRequestModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleRequestModel, type, buffer, offset, size);
                    SimpleRequestModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleResponseModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseModel.Verify(), "simple.SimpleResponse validation failed!");

                    long fbeBegin = SimpleResponseModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleResponseModel, type, buffer, offset, size);
                    SimpleResponseModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case SimpleRejectModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleRejectModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRejectModel.Verify(), "simple.SimpleReject validation failed!");

                    long fbeBegin = SimpleRejectModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleRejectModel, type, buffer, offset, size);
                    SimpleRejectModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case SimpleNotifyModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleNotifyModel.Attach(buffer, offset);
                    Debug.Assert(SimpleNotifyModel.Verify(), "simple.SimpleNotify validation failed!");

                    long fbeBegin = SimpleNotifyModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleNotifyModel, type, buffer, offset, size);
                    SimpleNotifyModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case DisconnectRequestModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    DisconnectRequestModel.Attach(buffer, offset);
                    Debug.Assert(DisconnectRequestModel.Verify(), "simple.DisconnectRequest validation failed!");

                    long fbeBegin = DisconnectRequestModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(DisconnectRequestModel, type, buffer, offset, size);
                    DisconnectRequestModel.model.GetEnd(fbeBegin);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace simple
} // namespace FBE

namespace FBE {
namespace simple {

    // Fast Binary Encoding simple client listener interface
    public interface IClientListener : FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding simple client
    public class Client : FBE.Client, IClientListener
    {
        // Client sender models accessors
        public readonly SimpleRequestModel SimpleRequestSenderModel;
        public readonly SimpleResponseModel SimpleResponseSenderModel;
        public readonly SimpleRejectModel SimpleRejectSenderModel;
        public readonly SimpleNotifyModel SimpleNotifySenderModel;
        public readonly DisconnectRequestModel DisconnectRequestSenderModel;

        // Client receiver values accessors
        private global::simple.SimpleRequest SimpleRequestReceiverValue;
        private global::simple.SimpleResponse SimpleResponseReceiverValue;
        private global::simple.SimpleReject SimpleRejectReceiverValue;
        private global::simple.SimpleNotify SimpleNotifyReceiverValue;
        private global::simple.DisconnectRequest DisconnectRequestReceiverValue;

        // Client receiver models accessors
        private readonly SimpleRequestModel SimpleRequestReceiverModel;
        private readonly SimpleResponseModel SimpleResponseReceiverModel;
        private readonly SimpleRejectModel SimpleRejectReceiverModel;
        private readonly SimpleNotifyModel SimpleNotifyReceiverModel;
        private readonly DisconnectRequestModel DisconnectRequestReceiverModel;

        // Client requests cache fields
        private Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>>> _requestsByIdSimpleResponse;
        private SortedDictionary<DateTime, Guid> _requestsByTimestampSimpleResponse;

        public Client() : base(false)
        {
            SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
            SimpleRequestReceiverValue = global::simple.SimpleRequest.Default;
            SimpleRequestReceiverModel = new SimpleRequestModel();
            SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
            SimpleResponseReceiverValue = global::simple.SimpleResponse.Default;
            SimpleResponseReceiverModel = new SimpleResponseModel();
            SimpleRejectSenderModel = new SimpleRejectModel(SendBuffer);
            SimpleRejectReceiverValue = global::simple.SimpleReject.Default;
            SimpleRejectReceiverModel = new SimpleRejectModel();
            SimpleNotifySenderModel = new SimpleNotifyModel(SendBuffer);
            SimpleNotifyReceiverValue = global::simple.SimpleNotify.Default;
            SimpleNotifyReceiverModel = new SimpleNotifyModel();
            DisconnectRequestSenderModel = new DisconnectRequestModel(SendBuffer);
            DisconnectRequestReceiverValue = global::simple.DisconnectRequest.Default;
            DisconnectRequestReceiverModel = new DisconnectRequestModel();
            _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>>>();
            _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
        }
        public Client(Buffer sendBuffer, Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
            SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
            SimpleRequestReceiverValue = global::simple.SimpleRequest.Default;
            SimpleRequestReceiverModel = new SimpleRequestModel();
            SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
            SimpleResponseReceiverValue = global::simple.SimpleResponse.Default;
            SimpleResponseReceiverModel = new SimpleResponseModel();
            SimpleRejectSenderModel = new SimpleRejectModel(SendBuffer);
            SimpleRejectReceiverValue = global::simple.SimpleReject.Default;
            SimpleRejectReceiverModel = new SimpleRejectModel();
            SimpleNotifySenderModel = new SimpleNotifyModel(SendBuffer);
            SimpleNotifyReceiverValue = global::simple.SimpleNotify.Default;
            SimpleNotifyReceiverModel = new SimpleNotifyModel();
            DisconnectRequestSenderModel = new DisconnectRequestModel(SendBuffer);
            DisconnectRequestReceiverValue = global::simple.DisconnectRequest.Default;
            DisconnectRequestReceiverModel = new DisconnectRequestModel();
            _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>>>();
            _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
        }

        public Task<global::simple.SimpleResponse> Request(global::simple.SimpleRequest value) { return RequestListener(this, value, TimeSpan.Zero); }
        public Task<global::simple.SimpleResponse> Request(global::simple.SimpleRequest value, TimeSpan timeout) { return RequestListener(this, value, timeout); }
        public Task<global::simple.SimpleResponse> RequestListener(IClientListener listener, global::simple.SimpleRequest value) { return RequestListener(listener, value, TimeSpan.Zero); }
        public Task<global::simple.SimpleResponse> RequestListener(IClientListener listener, global::simple.SimpleRequest value, TimeSpan timeout)
        {
            lock (Lock)
            {
                TaskCompletionSource<global::simple.SimpleResponse> source = new TaskCompletionSource<global::simple.SimpleResponse>();
                Task<global::simple.SimpleResponse> task = source.Task;

                DateTime current = DateTime.UtcNow;

                // Send the request message
                long serialized = SendListener(listener, value);
                if (serialized > 0)
                {
                    // Calculate the unique timestamp
                    Timestamp = (current <= Timestamp) ? new DateTime(Timestamp.Ticks + 1) : current;

                    // Register the request
                    _requestsByIdSimpleResponse.Add(value.id, new Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>>(Timestamp, timeout, source));
                    if (timeout.Ticks > 0)
                        _requestsByTimestampSimpleResponse.Add(Timestamp, value.id);
                }
                else
                    source.SetException(new Exception("Send request failed!"));

                return task;
            }
        }

        public Task Request(global::simple.DisconnectRequest value) { return RequestListener(this, value, TimeSpan.Zero); }
        public Task Request(global::simple.DisconnectRequest value, TimeSpan timeout) { return RequestListener(this, value, timeout); }
        public Task RequestListener(IClientListener listener, global::simple.DisconnectRequest value) { return RequestListener(listener, value, TimeSpan.Zero); }
        public Task RequestListener(IClientListener listener, global::simple.DisconnectRequest value, TimeSpan timeout)
        {
            TaskCompletionSource source = new TaskCompletionSource();
            Task task = source.Task;

            // Send the request message
            long serialized = SendListener(listener, value);
            if (serialized > 0)
                source.SetResult();
            else
                source.SetException(new Exception("Send request failed!"));

            return task;
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                case global::simple.SimpleRequest value when value.FBEType == global::simple.SimpleRequest.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleResponse value when value.FBEType == global::simple.SimpleResponse.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleReject value when value.FBEType == global::simple.SimpleReject.FBETypeConst: return SendListener(listener, value);
                case global::simple.SimpleNotify value when value.FBEType == global::simple.SimpleNotify.FBETypeConst: return SendListener(listener, value);
                case global::simple.DisconnectRequest value when value.FBEType == global::simple.DisconnectRequest.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::simple.SimpleRequest value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::simple.SimpleRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRequestSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleRequest serialization failed!");
            Debug.Assert(SimpleRequestSenderModel.Verify(), "simple.SimpleRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleResponse value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::simple.SimpleResponse value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleResponseSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleResponse serialization failed!");
            Debug.Assert(SimpleResponseSenderModel.Verify(), "simple.SimpleResponse validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleReject value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::simple.SimpleReject value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRejectSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleReject serialization failed!");
            Debug.Assert(SimpleRejectSenderModel.Verify(), "simple.SimpleReject validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.SimpleNotify value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::simple.SimpleNotify value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleNotifySenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.SimpleNotify serialization failed!");
            Debug.Assert(SimpleNotifySenderModel.Verify(), "simple.SimpleNotify validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::simple.DisconnectRequest value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::simple.DisconnectRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = DisconnectRequestSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "simple.DisconnectRequest serialization failed!");
            Debug.Assert(DisconnectRequestSenderModel.Verify(), "simple.DisconnectRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }

        public bool OnReceiveResponse(global::simple.SimpleResponse response)
        {
            ReceivedResponse_SimpleResponse?.Invoke(response);

            lock (Lock)
            {
                if (_requestsByIdSimpleResponse.TryGetValue(response.id, out Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>> tuple))
                {
                    var timestamp = tuple.Item1;
                    var timespan = tuple.Item2;
                    var source = tuple.Item3;
                    source.SetResult(response);
                    _requestsByIdSimpleResponse.Remove(response.id);
                    _requestsByTimestampSimpleResponse.Remove(timestamp);
                    return true;
                }

                return false;
            }
        }

        public bool OnReceiveResponse(global::simple.SimpleRequest response) { ReceivedResponse_SimpleRequest?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::simple.SimpleReject response) { ReceivedResponse_SimpleReject?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::simple.SimpleNotify response) { ReceivedResponse_SimpleNotify?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::simple.DisconnectRequest response) { ReceivedResponse_DisconnectRequest?.Invoke(response); return false; }

        public bool OnReceiveReject(global::simple.SimpleReject reject)
        {
            ReceivedReject_SimpleReject?.Invoke(reject);

            lock (Lock)
            {

                if (_requestsByIdSimpleResponse.TryGetValue(reject.id, out Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>> tupleSimpleResponse))
                {
                    var timestamp = tupleSimpleResponse.Item1;
                    var timespan = tupleSimpleResponse.Item2;
                    var source = tupleSimpleResponse.Item3;
                    source.SetException(new Exception(reject.ToString()));
                    _requestsByIdSimpleResponse.Remove(reject.id);
                    _requestsByTimestampSimpleResponse.Remove(timestamp);
                    return true;
                }

                return false;
            }
        }

        public bool OnReceiveReject(global::simple.SimpleRequest reject) { ReceivedReject_SimpleRequest?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::simple.SimpleResponse reject) { ReceivedReject_SimpleResponse?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::simple.SimpleNotify reject) { ReceivedReject_SimpleNotify?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::simple.DisconnectRequest reject) { ReceivedReject_DisconnectRequest?.Invoke(reject); return false; }

        public void OnReceiveNotify(global::simple.SimpleRequest notify) { ReceivedNotify_SimpleRequest?.Invoke(notify); }
        public void OnReceiveNotify(global::simple.SimpleResponse notify) { ReceivedNotify_SimpleResponse?.Invoke(notify); }
        public void OnReceiveNotify(global::simple.SimpleReject notify) { ReceivedNotify_SimpleReject?.Invoke(notify); }
        public void OnReceiveNotify(global::simple.SimpleNotify notify) { ReceivedNotify_SimpleNotify?.Invoke(notify); }
        public void OnReceiveNotify(global::simple.DisconnectRequest notify) { ReceivedNotify_DisconnectRequest?.Invoke(notify); }

        public void OnReceive(global::simple.SimpleRequest value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::simple.SimpleResponse value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::simple.SimpleReject value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::simple.SimpleNotify value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::simple.DisconnectRequest value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }

        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();

            foreach(var request in _requestsByIdSimpleResponse)
                request.Value.Item3.SetException(new Exception("Reset client!"));
            _requestsByIdSimpleResponse.Clear();
            _requestsByTimestampSimpleResponse.Clear();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);

            while (_requestsByTimestampSimpleResponse.Count > 0)
            {
                var request = _requestsByTimestampSimpleResponse.First();
                Tuple<DateTime, TimeSpan, TaskCompletionSource<global::simple.SimpleResponse>> tuple;
                _requestsByIdSimpleResponse.TryGetValue(request.Value, out tuple);
                var timestamp = tuple.Item1;
                var timespan = tuple.Item2;
                if ((timestamp + timespan) <= utc)
                {
                    var source = tuple.Item3;
                    source.SetException(new Exception("Timeout!"));
                    _requestsByIdSimpleResponse.Remove(request.Value);
                    _requestsByTimestampSimpleResponse.Remove(timestamp);
                    continue;
                }
                else
                    break;
            }
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRequestReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestReceiverModel.Verify(), "simple.SimpleRequest validation failed!");
                    long deserialized = SimpleRequestReceiverModel.Deserialize(out SimpleRequestReceiverValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRequestReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRequestReceiverValue);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleResponseReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseReceiverModel.Verify(), "simple.SimpleResponse validation failed!");
                    long deserialized = SimpleResponseReceiverModel.Deserialize(out SimpleResponseReceiverValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleResponse deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleResponseReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleResponseReceiverValue);
                    return true;
                }
                case SimpleRejectModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRejectReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRejectReceiverModel.Verify(), "simple.SimpleReject validation failed!");
                    long deserialized = SimpleRejectReceiverModel.Deserialize(out SimpleRejectReceiverValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleReject deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRejectReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRejectReceiverValue);
                    return true;
                }
                case SimpleNotifyModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleNotifyReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleNotifyReceiverModel.Verify(), "simple.SimpleNotify validation failed!");
                    long deserialized = SimpleNotifyReceiverModel.Deserialize(out SimpleNotifyReceiverValue);
                    Debug.Assert((deserialized > 0), "simple.SimpleNotify deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleNotifyReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleNotifyReceiverValue);
                    return true;
                }
                case DisconnectRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    DisconnectRequestReceiverModel.Attach(buffer, offset);
                    Debug.Assert(DisconnectRequestReceiverModel.Verify(), "simple.DisconnectRequest validation failed!");
                    long deserialized = DisconnectRequestReceiverModel.Deserialize(out DisconnectRequestReceiverValue);
                    Debug.Assert((deserialized > 0), "simple.DisconnectRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = DisconnectRequestReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(DisconnectRequestReceiverValue);
                    return true;
                }
                default: break;
            }

            return false;
        }

        public delegate void ReceiveResponseHandler_SimpleResponse(global::simple.SimpleResponse response);
        public event ReceiveResponseHandler_SimpleResponse ReceivedResponse_SimpleResponse = (response) => {};
        public delegate void ReceiveResponseHandler_SimpleRequest(global::simple.SimpleRequest response);
        public event ReceiveResponseHandler_SimpleRequest ReceivedResponse_SimpleRequest = (response) => {};
        public delegate void ReceiveResponseHandler_SimpleReject(global::simple.SimpleReject response);
        public event ReceiveResponseHandler_SimpleReject ReceivedResponse_SimpleReject = (response) => {};
        public delegate void ReceiveResponseHandler_SimpleNotify(global::simple.SimpleNotify response);
        public event ReceiveResponseHandler_SimpleNotify ReceivedResponse_SimpleNotify = (response) => {};
        public delegate void ReceiveResponseHandler_DisconnectRequest(global::simple.DisconnectRequest response);
        public event ReceiveResponseHandler_DisconnectRequest ReceivedResponse_DisconnectRequest = (response) => {};
        public delegate void ReceiveRejectHandler_SimpleReject(global::simple.SimpleReject reject);
        public event ReceiveRejectHandler_SimpleReject ReceivedReject_SimpleReject = (reject) => {};
        public delegate void ReceiveRejectHandler_SimpleRequest(global::simple.SimpleRequest reject);
        public event ReceiveRejectHandler_SimpleRequest ReceivedReject_SimpleRequest = (reject) => {};
        public delegate void ReceiveRejectHandler_SimpleResponse(global::simple.SimpleResponse reject);
        public event ReceiveRejectHandler_SimpleResponse ReceivedReject_SimpleResponse = (reject) => {};
        public delegate void ReceiveRejectHandler_SimpleNotify(global::simple.SimpleNotify reject);
        public event ReceiveRejectHandler_SimpleNotify ReceivedReject_SimpleNotify = (reject) => {};
        public delegate void ReceiveRejectHandler_DisconnectRequest(global::simple.DisconnectRequest reject);
        public event ReceiveRejectHandler_DisconnectRequest ReceivedReject_DisconnectRequest = (reject) => {};
        public delegate void ReceiveNotifyHandler_SimpleRequest(global::simple.SimpleRequest notify);
        public event ReceiveNotifyHandler_SimpleRequest ReceivedNotify_SimpleRequest = (notify) => {};
        public delegate void ReceiveNotifyHandler_SimpleResponse(global::simple.SimpleResponse notify);
        public event ReceiveNotifyHandler_SimpleResponse ReceivedNotify_SimpleResponse = (notify) => {};
        public delegate void ReceiveNotifyHandler_SimpleReject(global::simple.SimpleReject notify);
        public event ReceiveNotifyHandler_SimpleReject ReceivedNotify_SimpleReject = (notify) => {};
        public delegate void ReceiveNotifyHandler_SimpleNotify(global::simple.SimpleNotify notify);
        public event ReceiveNotifyHandler_SimpleNotify ReceivedNotify_SimpleNotify = (notify) => {};
        public delegate void ReceiveNotifyHandler_DisconnectRequest(global::simple.DisconnectRequest notify);
        public event ReceiveNotifyHandler_DisconnectRequest ReceivedNotify_DisconnectRequest = (notify) => {};
    }

} // namespace simple
} // namespace FBE
